

    local Byte         = string.byte;
    local Char         = string.char;
    local Sub          = string.sub;
    local Concat       = table.concat;
    local Insert       = table.insert;
    local LDExp        = math.ldexp;
    local GetFEnv      = getfenv or function() return _ENV end;
    local Setmetatable = setmetatable;
    local Select       = select;

    local Unpack = unpack or table.unpack;
    local ToNumber = tonumber;local function decompress(b)local c,d,e="ScriptGuard","ScriptGuard",{}local f=256;local g={}for h=0,f-1 do g[h]=Char(h)end;local i=1;local function k()local l=ToNumber(Sub(b, i,i),36)i=i+1;local m=ToNumber(Sub(b, i,i+l-1),36)i=i+l;return m end;c=Char(k())e[1]=c;while i<#b do local n=k()if g[n]then d=g[n]else d=c..Sub(c, 1,1)end;g[f]=c..Sub(d, 1,1)e[#e+1],c,f=d,d,f+1 end;return table.concat(e)end;local ByteString=decompress('26I25C27525D25Q27525C23W24023S24F23Z23M23Q24524323N23L24423P23O25D25J27927B27D23U23T24425D25N27R27C24F27U24424F23X23L24825D25T27Z27D23Y23Z24F24623T24224424523L23W23T24A23P25D25R28A24F28C24F24524024628K24523P24325D25M28R23P23Y23N24324424229229429623Y24523X25D25L28R23N24223L24323S25D25I27924M24S24P24N24O25025E25D29B27529S29U29W24T24V24K24L2792A927627Y2A129T29V25024Z24W24L24L24K2AA27526C23K25D25G27924N24H24T24L2A025C23R24L25024324L24Y25224P24J2AW25S27926426P21R22M21026G29I2152651023G1B161G2172AX26326V21G23J1826S25R26421Q26J27P27924024S24H2552B324Z27X27R24V24J24H24S2C32C52B325D25H2792AH24H2B725E25C2CI2CK24O24P24M25029Z2792532CW27524H2CZ25C2C825D27924K2AX23T24U24W25125023M24L2AT24U2C127523N24V24U24U24L24J2CV2932752D92DB25023P24U2A72D729I27523S24L24H24Y25024I2E32CV27Q27524325024L24W2AI2D72EA25C26126M21N22D2BV25M2D527929P2CK25024Y24P24U24N25D25F2CK25124I2AQ27924J24O2E42AM1W24V23K2AM25C21C27325D25U27923T23M22I21823123Q25525122L23Y22T1E23H2332372262382242FD26Q2FC2FD23K26P2CO2CP2ER2FD2EQ25C2AR2752GE25C2EI2EI2DR25C2GK28Q2752GN25C2FI2752GR25C25X2792GV2752602792GZ27526427926527926627926727926A2HA2HC2AM2HB2752HF25C2HH2HJ2HD2HI2HL2HK2HG2HN2HQ2HP2HS2HM2HT2HO2HU2HX2HW2HZ2HR2HY2I12I02HV2I12FD2I22I52I92AA2I42I82HX2A92IC2IG2I32II2HT2IF2I62IJ2ID2HW2I72I72IC2IQ2FD2HH26B2792IW2752IY2AA2J02J22IX2J42IZ2J525C2J32J62JA2J82J72J92JC2JB2JE2JH2JD2JJ2JG2JK2JF2JN2JI2JL2JQ2JO2IT2JS2JR2JP2JU2JX2JW2JZ2JM2K02JR2A92K22JY2K12JT2I72JW2K82K427926C2KD2KF27526E27926F27926G27926H27927427526J27926K27926N2KV2792732KY2KX27523L2792L32752412792L72L22792432LB29R2LE2A12LF25C2LC27524P27924Q27924R27924S2LQ2LS2AM2LR2752LV25C2LX2LZ2LT2LY2M12M02LW2M32M62M52M82M22M92M42MA2MD2MC2MF2M72ME2MH2MG2MB2MH2I72MK2MI2M92A92MO2MS2MJ2MU2ML2MW2MP2MD2MR2MV2MY2MT2KB2AA2MO2N42M92522792542NA2792282ND2NF2752NE2NH2NC2NJ27522B2792NN2NM2FD2NP25C2NS2NU2NO2NW2NQ2NY2NT2NX2O02NZ2NV2O32O12O42O22O82O72OA2O62OC2O52OE2O92OD2OG2NZ2I72OB2OF2OL2OI2OO2ON2OQ2OH2O72A92ON2OU2OH2OW2OM2OS2N72OY2OO2P12NS22C27922D2P72P92AM2P82752PC25C2PE2PG2PA2PF2PI2PH2PD2PK2PN2PM2PP2PJ2PQ2PL2PR2PU2PT2PW2PO2PV2PY2PX2PS2PY2I72Q12PZ2Q22PQ2A92Q52QA2Q02QC2Q72Q62PU2Q92Q32QD2QF2PT2P12Q52QM27922M2QP27922O2QS27922Q2QV27922Y2QY2QX2752QZ2752G72GS25K2GA27525I2GP2AR2GC25G2452792RC2GD2RF2GS2G925E24E2FD25U2NI25C2G82RR2RN2762792RP2792F02752RM2792RS2RX2GF2S22RU25C2RZ2GQ2RQ2CJ2S02S72GG2S425C29Q2SD2792SC2SA2792EI2S12R92RW2RQ2R72792562AA2F026O2RS29I29326O2A927Y25O25C2T227925P25C2782GR2D52GP2682RV2D52B925U24X2GD25C2892AA29Q2GG2G829Q2SI2A92TS2AM2TV2D52GR2R72HH2GR29I2J02TF25C29I29I2KE2GR2932U427529329326D2T32AA2GR2T52T52RK25C2T92KI2UM2782KK2S525C2T526L2G925C27125C2B92GK2UY2TM25C2GP25C21U2V02RR2VA25C25V25C27Y28Q2B92VC2VE2V928Q25G2582UU25C2KK2TY2622VO2KM2GS2VS2T92US2KH2TA2SH2RW2VS28Q2VY25G23M2UN25C2502G926824Y2V42B92KK26824V2V42892KO2U52892892VY2GQ25C2ST2A92VD2EI27925W2U62AM2GV2TT27925Y2V92AA25Z2X42A92WX2X62RS25C2WX27Y2WX2GW2WY2AA2X32UL2A92X62TN2A92GZ2XN2XG2GZ2XB2GV27Y2GX2752X62XF2XO2GU2S22XX25C2X62X52Y42AM2X62X62TY2752612VP2RW2752VS2XK25Q2FC2T523X2G92X62RE2792YM2D52YP27524D2G925Q21S2VO2YV2D52GZ2YT25C2Z025C26824T25C2632Y72742Z725C2H32GZ27425I24H2Z925C2442G92H32Z32ZM2YS2RJ25C2RF2EQ26M25C2VS2VS2YD25C2GZ2H52X62ZA26825A25C2H52H52KQ2752H72GZ2H32U52H72H72ZC2YC2EJ25C310B310125C2H72Y62H52UT27523U2G925I23T2Y724G2G92Z22ZS31102EQ2UZ2X62H12TA2YK25C24J2YN2RI2F52G92Z32Z82D52ZD2ZA2X62742YJ2VO24N2G92ZA2Z3311Q2ZR27924O2UX2ZW2ZY310L310O2H331042Z62KU2H32H32ZC269310L2YD2KQ31162ZE2RG31132UX2UZ2VD2VS2792UZ2WX2ZA2792N92782A92Z32TK2EQ26Q2VI27Y2VD25C2722WR2WQ2VD2VM2W8312X31152S83133312M2TL2E02752N92GG2GF2ZS2NB2EQ2L32D52F02CO25U2R72CO2TE2T92CO2CO2TI2TK2CJ2GT2SN25C2SL2G827Q2WV27531452AM31482YB2WY2U12UD2JN2U52UE25C2U927527Y2UC2VJ27Y2UG2792XK2UM2T92XK2GR2782UP2WQ2V52YE2UT2T92NE31392892AC2752UZ2FI2VH2752V8289313V2752VD2T52B92TN315G2WE2GD2VN2T92222G925U2VW25C2VU2GQ2VS2UR2A92KI28Q2EI315R2V92W52W72781K2WB2WD2FI2WO2Z62WI2FI2FI2WL2RK2FI2WP2VD313E2WW313B2A92GV2V22752X331462Y72XQ2GY2V42AA2GV2XS316O2VO2XW25C2X3316Q2Y72T92AA2GZ3140310K317B3174310L2XB2XJ317E2H02Y12AA2YD2X32S0316W3118317J317Q317P315Q2YG3150314Y2ZA2YI2YY2T523I3111311E27531822D52YX2VO3186310L2Z3318A2ZD2ZF310M2Z62Z82H5312C2SH24Z312F23A2G92H52Z3318O2ZV2ZK2ZA312L2GZ310D312F3106310P3191310N2H92YD2H52U52H92H9310J2ZX319B310N2YD2H931793191310T25C231310W310Y2GZ112G92YD2Z3319O31392GZ310031192VO1431832Z3319Y311V2751D2WB2Z8318F311N318025C182ZN318431AA311Y318U319B310O2H5310E3125310831AM3129319B2VS312D31AI312G279319S31572XC2ZK313C2GV2H3312Q2W0312T2ZS1H2UX312X2WX2T52XF313229I2VD2WX31362782P831392AR316L2UZ2CJ2V22N92SL313I2791O2UX2L32CO2AR313P2LP2F02TE2752F02F02VD2U531C331AX2RG27929Q2T72AR2GV2X331CC2Y731CF2S52GZ31CI2TL317M2T62S52VS31CL2AR2ZA2X32682CJ2CJ2D5310F2T931CW31AM25I26V2GH31D52D52EQ23R31C92792TF2CJ27Q311J31D12D52H726831D0314231D231D427Q2R731D727531D9319I31DC31D62Z631D12CO2H931DJ31DL2CJ2H531D331D529I313N31DR2I731DS313A27931EA313H311Q31DD2UX27531CX2TW31EH2GR27Q312S314Y2R731C131332R7313X2VJ317D2T931562G82T931782A931F02AM31F3314B28Q314D2V9314M2B92B9314J2V4314M2WN25C314P2UM2YF2VI314U2752WX314X2GR2GV2W5315F2TA2CZ312E2XQ2UZ31CK2A92V82XA2VB2VD2FI2X32Y531G431CH315M2VI25K2CW31622VD315U31622WX2WP2KI2GV31F131622X3316431AX291311J2WD2GZ2X62WG2WI2GZ2GZ316G310O2GZ2WP2YD2V6317V31EO2792ZA315A2BA2W82AA31032AM2H72Y52A92ZA2H72XB2ZA2FI312P2H22X72H42VI2AA318Y2AA2H9317S312F2H92XB2H32FI31B1310C31AY2A92H931I32G8310H31HF319H2A931IA314B2TF2VY2GR312A2YI311A26M2CW2H72Z331IM31A22UY2CW31882T52712CW2H92Z331IW311J2Z82HB310I318H2JC3199318L2HM26T2CW2IW2Z331JA318T312A312A2U52GZ2KE2H72HB31902KE2KE310N2UG2H92IW2U52UG2UG319A2TF2TF319331FH31IB2KE319I2C02D5310X31912AP2D531IY2ZS31K931AW2H7319F319W2T523N31IN31AD31KJ31IR23W2CW2ZD31J3318G31IU2AY2CW2HB2Z323R2CZ2ZW31JG2Z6316W2IW31JL31AL2IW2IW31AO31JY318G2V32H72J02Z331KD2V32VS312A313C2ZA2HH25C312R2AA2Z32402CZ312X2VS2FI312L313228Q2YD2VS31362WX25V31FV2GL314Z313C27Y31HA2N9315631BR2752472CZ2L32R7293313V2RN2T031DB31BN313331JY2T9314H31E331D42T527Y2YS31E82SQ31EC279316L31EA31BQ31EA2WV2TF2932T52EQ2H531BQ2GQ2R72CJ313T31E12V92TJ313331LJ2A92932WS2G8314H2AA31NP31NL31M5314B2T531F82T9314M31F331FD278314M27827831FI31M631FK2B931FM2V431FP2RK31FS2V925531M42WX31H72UZ2GV3130315B31AX315E2VI28Q31BE31FT28Q31M231GA2B92D4315V2V931GG2VS316B2792KI2FI2GK31GE317W2W62V423J31KP2WD2GV31GI316C2Y12GV31H02GV31FR2A9317H2Y631MB316W31F12792YD31762VS2XZ31H831C82Y02ZA2XB2GZ28Q317Q2YD31PR317V31HA2752ZA317331HP31QB310L2H32XB31H4312131Q9310O2AA2H3319V2G82ZA31HO31PX31QQ31QJ2ZA314B2H531IH31I4317Z2VO22V2CW311S2ZS31R1318731A931R5312F2Z331R82ZD2H92ZA2ZC2Z82TF312831J82H922N31KP31AD31RL318T31IA310S2GZ312A2ZA31DZ310731L1310N2HB310F31L22HM2HB319A310931LB31HP31LM31QJ31NK313H22E2CW25I2GV2ZA22Y2CW2ZO2ZS31SH31IR22Z31M42ZA31I3311O2T523231R231AD31ST31IR23C31KP2Z831RD31KS311A23631IX31AD31T431IR23731KZ31912H731RR31L231RU31AL31LA31AO31S531AR310531AT27531SN31392X6310Q31AW2GZ31KG31LN31B331TM25C23G31LS2Y728Q2Y531322T531G631GA28925A31M427Q314R2UZ2R731PR2N92WS31MC25C1331MF31DL27Q2CO31CV2W12CJ2WX313Q31D531NF314831EU293317D2T52GK2G82UK2AM31V32AA31V3314B27831F828Q314M28Q28Q31FD2B931FA2V931O5316V2GR2FI31O92VD31OB31AX31OD2FI1S31M42X331HA312E31732V82X331OO2VD28931CE31FT2892X32GV31362FI1M31GD31LU315T2W22VI31GJ31AX314U2VS31PL2GF2W72VD26A29Y2Z62WD2X631GO31PG2Y925C31H031WW2WP2GZ31H7310K31Q6319B31H52ZK314R31HP317N2A92H531XA2792VS2H52XB31P131AH31QJ31X631I12AM31HE31HT2Y72AA31HJ2VB31QJ28931QQ2H5312L31ID31I52G831S531HD31AM31Y32H5314B2H931QX31L231QZ31MU31WQ318Q2ZS25N31WQ31SR25C21Q31KK2Z331YK31IR31YG31J125C312A310A31J531KR2ZH318M312A25F31WQ31KW2ZS31YZ318T31LA319F2GZ2IW2H531JH310731L731S6314I319131JM2AN31ZE319A319831ZD2H731K331XB2JN313H21L31SD310Y2H525Q31WQ31IO2ZS31ZV31392H531TR31YI25T31YD31AD320431IR26331WQ2ZD31YS31T2317231WQ312A2Z325X31WQ2Z325Y31WQ25C2ZW31Z5316W2HB31Z931AL2HB31S32Z6312A31ZK31AR2H52HH2Z331ZZ31AW2YD2U531AW31LI2A931LO31B42H8320M312X2YD28931003132278319U31GA2VD1X31M429I31OI31M52V62N9316Q2Z326E320M2L327Q29I2CO31E42R731N82UX31EA2X12UZ29I31UH2KW31E62WB2CJ29I27Q31DZ2T92U731DM2VJ2T931DQ2AY31CA2A92TF29I31MV2KR2R831TW2A92S9322Y31DA31EB2752742GC2792G13234322U2RV2JT2S92TT2TT2EI2S9318G323725C32362AM2KS32392IT2S9313E313E2GK323F32332AM323J2AA323L31EH2IQ2GG31EO32412792RB31CA31D42GC322N31EA31XR2RL2A9323X32472FD2SL31F1324H2T827931EO31BQ2F0323H317O2GB2I7324O322V2AA32342S92XN2XN2GT323S323Y275323V324C324T2I72S92XZ2XZ2XW3250323H3253279324D32562ER2SL24W2EV24U2CV2SL2A724I2512EY313E2EU2CM24L24I2CM24R2EI31HH326027932612Y3316W31472RW21V322V2TC31XT2U531DQ323F322N2P1324R2I72XN25D31F124524Z2B32DT2DC2442552AI2F42752DW25124T25D2WS23V24L25524I24V2E42EH27932712552DK2A72D231ME2GC25329Y2D223L2D22D12GC31GR2CK2D227O2GC2D72SL24324W325U2CQ2752CL2B729H27R24L2CU2432CS2CU327X2D332862502KZ2752T731CO328D279328E328E2A9328E26P279328M2R4328N328Q2AM328O25C312X275328V328U27926R328Z329127532903293329225C26S2793298275329A25C26T279329E275329G329D329F329K27526U279329N329M27931D4275329S25C329U329W329R27926W329Z32A127526X27932A432A332A532A82AM32A625C26Y27932AD27532AF25C26Z27932AJ27532AL32AI32AK32AP27527027932AS275328C25C32AW26824A31EH314B31OO31S1315E311J317O2CO2F02SI2D531DE2VA2Z332BC2Z3313231DF31EH2AR31UT32B331UP315E2AR32BN2VA2CJ25I318M3187324B3212311G2ZS2892EQ23P325126O32AJ31K631D532BG322D32BJ31NC2VA2RS32BQ31BW31DW32CC31332ZI2G92VS2D531BW2ZS32CL326V32C332C52WY27Q32C832BI2RD32CB32BM2CJ32BO32CG315E29332CJ2D52IW32CM31AD32D732CQ323732C42G927Y32CU2ZS32BH32CG32CX32BL326B32D032BD32D22VA2T532D525C2KU32D82Z332DU32DB2AA32DD2D52T932DG27932DI31UP32DK313R32DM32CH32BP32DN2CO27832BT2G9329032DV2ZS32EH31AD329N32C132CR2G9316031AD32E531EJ2S532DL32CD32EC2TL32CE2V932DS32DI32CN32E42UX32C232DC32CS2892EA325F2AM2882ER326L326N24Y326P250326R326T2GG326W326Y32703272327432762DI25C3279327B2AW2GC327E2CX2CO327I327K2D2327N327Y327P2D2327S2LB327V32802SL327Z2AW313E23W32832B1328A328824Z328A2G425C2W727532GQ32GP27932GS32GV27923N32GX32GZ2DJ32H025C32GY27523O27932H632H527932C232CQ32HC25C32HB32HE2FD32HF23Q27932HJ27532HL322O31MX32HO32HQ324931MZ2E127923S32HV2FJ32HY2DS32HZ25C310Y2AM32I325C310V310U27932I732FU327832IC27523V32ID32IB27523W27R32IK2752YM32IM2YQ32IP32IO2AM32IN25C23Y27932IV2L627932GO2682LC324E2GR32BM32B72WB32J632B92RV2KZ32EI2L032CW31C932EV31MM32EA32DP2CO32BS2ZJ2TD32BW2ZS28Q32EN32F7310W32C72ZS32JB32DJ32JF32E832EW32JI32EZ2R732EF2D52X332JC316R32BY31PS32F532EO2D5322F31AD32JW32E632JY32CH27532EZ32EB32CH32D432BU31L232K732KQ32D932KB32JS2D532DF32KF32C932E732KJ32JJ32EY32EX32DR32KP323T32F3323232K92752UW32JR32DZ32CS32E232KY32JE32EU32JZ32JH32D132EZ32EE32JM25C32EM32BD2ZS32LR32HG32KV314Z32E332AV32KZ32KI32CZ32K132EX2B932K42V332KR2UZ31IR32JW32LV32LE2G932F93238325127632162ES2AD2A32CV313E23N2F724Y2CM2ED24Y27732HK2EW24K23Q24P24Y24Z25032MP24P24S2D7315A25D26V21J2251326H25S25T1F2691A23E2191E1121M2C932ML2AF2AH2AJ2AL2AM2AO25D315A23S326X24H24U24V24P24K24224V24V2502402E42CV2TT23N23Q32MR2AV2EZ2792DN2CY327R2IQ32G332GD32GB2AW32GD32GK2GC31OX2752CY325I24H32N02C831EO2AZ25023O24L24Z2B72DX32O12AG32OI2DS24Z327J2WS25N26B21522121P26F25N29Z2WS24624L24S2CB24P25031OF2EI32PQ2DP24V24Y26R32NP25C32O625032PQ32PS24J32PU31OF2A932MK2D32EU2EW2EY2S924Z2F2326U311B32MQ2F92FB2FD2FF2FH2FJ2FL2FN2FP2FR2FT2FV2FX2FZ2G12AM2G32I723K26B2EQ2ZM27532R92ZL2FD32RB32RE27932RB2A932RF32RA32RG32RL2AM32RJ32RC32RK32RQ32RP32RS32RO32RU32RM32RT32RW32RV32RR32RZ32RX32S032RY32S432S332S632S232S832RO2I732S132S132RI32RW32SE32S732RH32S532S932SJ32SC32SL32SN32SH32SO32RS2P132SD2N732SA32RW2ZS32SX2792ZS24627924732T232T427524927932T732T627932B027532TC25C32TE32TG32TB32TI32TD32TJ32TF32TL32TH27524B27932TQ2AM32TS25C32TU32TW32TR32TY32TP32TZ32TV32U132TU24C27932U52AM32U725C32U932UB32U632UD27532UC32UF32UE32UA32T82792YV2YU27924F32UO32UQ27532UP32US32UR25C32UT25C311027532UZ2AA32V132V327932V432V032V532V832V732VA32UY32V932VC32VB32V632VE32VH32VG32VJ32VD32VK32VF32VL32VO32VN32VQ32VI32VP2IQ32VM32VS32VB2A932VV32VV32VY32VT32VZ32W232W432VX32W532V232W732W02N732WA2N432VV2ZJ2D027932WF25C32WI32WK32WH27924I32WN32WP27532WO32WR32WQ25C32WS32UW311F2LG2IZ2GC32F62AA32KH31DQ25I315P2D531EJ31IR31EJ2Z326A2CZ32X22GC32X42VA32X62G929331DQ2Z332XL31AD32XD32LD32XG2UG31DQ31UO2TG313A2GR2AR313H2SQ2TQ2SQ2X132Y331EK29Q314B2R731182U231QI2U5322J31WD31M5319V314G31M531QQ31PP2UJ2VJ314S312F2UQ31Y42TL2VO2HB31392V12A92UZ2892V62V82B931W12VJ2VG31FT31M8314Z31362T52H32VR2VO31TR31622T9310S2VZ32EE31WF28Q32ZH31P92T9311X31GS315L31962WI31FG31DZ27531FG32ZH2WQ31UH31FT316T2WX316L2752X02AM31VV2Y831HQ31FN2Y72XB2XD31PY2Y13304317E31X8316U2AM2XP2WZ310O2XT2VJ31732XY330L317K2VB31WW2Y631HH32622Y7314B319531FK2VS3156311O27Y2W72D52YO2ZS331831AD32J2319W27Y32X2311232HA32LA2LI31A52ZK2X631JY31A6310O2TF32CJ2ZA310V31CY31AD331V31AD32IF318T3120310031022Y73105310731S53216319131AK310G319131LA312B31S1316W31TR330Z32ZM2A932JW31K72X632T12Z131AD332P31AW3117324K2YY27Y32LP331A32WM31YQ311L31L2318827Y32U52D531R332UD3321319B3323312F31242683126318Z320W332F2U5312E31I32Z3332S2V3312K32YX31AX31QQ321A31TX2A8312W312Y31HS31322R72FI3135315N2YE31392F031UH2UZ31BK321932YS31TX2LR313L2G9313O2SH32X725C24W2G931IR334L31IR32XQ32DY322Q21Y334M31DL326C32JT2GA323H32B32RY31EH31C6313A32XV313A2F027Q2U52AR3347314Y2CJ2WS2U531D129I2U529Q2CO32D42SQ2YY2RD2ZS335N2SH32ZJ21T334U2Z3335T32ZC29Q315631UP31UN2VO2RA31D5334T335O2793365335R31D521Z335U2ZS336B32ZC27Q31MB2GZ2TV335831EG2CO2T932XJ27Q323J31IR323J2Z3226310W27827Q227336C279336Y336F32YN32CG32E832EE28Q2R72P63366275337933692R731BI331K337F31622R7336H31D531DO33742VA28Q32XJ2R722I336Z275337S31IR22K336V313322L337T25C338032ZC337J32JH322032F028Q29I2QW337A25C338B336929I22R3381338H32ZC322S2Y02R72R72E0329E335D31XT2TL2AR2CJ2VH335B32BK2S5316V31DL32XG31EI31DL335531D1314032BS2AM2GG2TP322Q31KP322I313331G42TK31BA2AM2782XK2G831O3339J322W275339N314B2B932YA32ZW32YC339V28932YF2FI32YH316H31I531HS31FK330E2UM31B031FK2X3332K31AX31A131TS314Y321431XQ31OM31702G82VD2VD332U2VI2VD31GU31GA2WX318A31GH31IC31622GV32ZY2KI2X331EO31622X632ZM2W72XU31PC310L33242WH332F32ZV332F32ZY2VS31Q82ZK31XL316X31ZO31X2332A2AM31HW2AM2H331HZ2A92H32VD31I331AM33902H731PW27531942AM2TF319V31HR2TF2XB2H52VD32ZY31I733C232YR2G831ZK31HV25C31TU33C033CH317U31YR32YR2GR2HB33152FC27Y2102G931KB27933CT31IR21G2YW332W25C33CZ32B62Z333D331J52IW32ZV2ZD2KE31LA32CJ2IW2172G92KE2Z333DF31IR21831AF320U33CM310O31JR2JC319031JV332G25C2KI2TF33DB2VZ33DW31S131L133292TF314X2H831K1319I1X319L33CK21J32J72Z333EC313933BC331F25C21M33CU31AD33EK31IR25G31SZ31J6333333CR31YJ2G931JC2ZS21Q331K21R33DM2HM31LJ31JJ33CK31JT2KU31JO31L226831L131JH31AW2H931ZN33EE312I2ZK31LM2UZ2H32J031TV31X22Z331GC333X2ZA2VD312P31322B92VS311S2VN2GV1933FH32Z7313C2T52XQ2N931X82Z325R31UL338L322133892Z62D22Z326831GD338O317I2Z63110322J29I2UA33732GR27Y315632YM31PP2WY2T5313W2752R72GV33GP27529I31XA32YD2WY33H331M533GU314K33GR27531MU2AM29I33GY2X42R72X629I25I21X2TL23232JO27933HQ2EQ32FB324U2GK32PC32Q42C533HY32OK32QL24524U32PU32R5328132OW32Q024R32GE25D31HO32MZ2DX32OA2E523Z24U2422C524732PU24O23T24N32O224Y24L23W24P32N233HY24W24S32MU32MO32MQ32MS2CH2TT2CC2AV32MR25F32ZH2WI2AM33JC25C33JE2A933JE334L27533JJ334K27933JL33JO2792TK27533JR25C33JT33JV33JQ33JX33JS33JY2D32CK33K2327Y33K325C25127933K7313F31HR2R9315P31C23381324N31AD32CP32XJ32C632XM2ZS32Y733KH315Q32E832XG2LL315E2XB323F31S12RH2F03359338T2A932CF313P33KE2SL335332J92SK338S2SQ2S332662EI2U53148334133H02XH2TU3133334F32J92CO26E33K72F02GZ2D52932Z333LR275220334C31N02TL3234311S338S3387324A335033HV33L131I333IY33J033I832H333J32DP2CH31EO33IF32MY32P032N32CS32N632NX2ER32NA32NC32NE32NG32NI32NK32NM32NO32NY32O032O232O432O632O833IH2CV2WS24024V24Z32PU24P2DL32QD32OE32OG2AW2GK23W32O724R32PY25032Q033I124L2532P125G1032FT33NL32Q032942AA32NW32OY32P032MV31DR2B032P532P724L32P9325L2C82S923T32PE326Z27932PH32PJ32PL32PN33OE27532Q732PT32PV32Q332Q533OM32Q933OO32QC2TT32N2325K32QH2F12F32GG2F62F82AA2FA32GO2A932QR2GT2FK2FM2FO2FQ2FS2FU2FW2FY2G02G233P62A923K32PN27525527933PP2752SV33PS2SU33PV2AM33PT25C33PY33Q033PW33PZ33Q233Q133PU33Q633Q333Q733Q533Q833QB33QA33QD33Q433QF33Q933QG33QC33QI33QE33QH33QM2IQ33QL33QJ33QN33PY2A933QP33QS33QK33QW33QR33QX33QQ2AA33QP33QT33QZ33R22N733R52N433QP2572792VN275310733RD2FD33RE25C25B27933RJ27533RL33RI33RK33RP33RM279335T27533RT25C33RV33RX33RS33RZ33RU2792V831OM33S42V733S227933HO27533S925C33SB33SD336733SF275334T33SH33SG25C33SI33SL33SK33SM33SP27933LX33LW33SR33SU33ST27522127933SY2AM33T025C33T233T433SZ33T633SX33T733T333T933T533T833TD33TA33TE33TC33TF33TI33TH33TK33TB33TM33TG33TN33TJ33TP33TL33TE2I733TS33TQ33TT33TP2A933TV33U033TR33U233TO33T133U333TW33U733U133TX2N433TV2P133TV33KD25C33UF33UH27933UI27533UF22327933UN27533UP25C33UR33UT33UO33SV323I2NG2VE2EQ31UT326F32XH33GD32XK33GG2ZS2EP311J313U334G2GQ313Y33LY3266314333LC314931D52AA314A314Y29I2XZ33GQ2XW32YI2932X333GS330U2U533GT33AH2VO2A92GR31MQ31FK321J31FK31LY31DA2T932CP2V33155333R315931G02V432Z3315H316X315K2892B931362T92WX32ZC33W831WF27833C4315Z33VJ31OY2B9319V31P927832LP2WC2WQ321G31PG316E2ZK2U533X633C4316K2AM2WX33002Y13176316S33093390330M316Y330O31712T531733175330931X4317A2AM2YD317D2X32YD317G2VO31XD2GZ31QD31CN324P31GY330T31HX33Y6314B2ZZ31FK2ZA2GK3188293331Y331I32I831872FC29332AS2D5319Q2ZS33YN331X331M318F310F318I31QE2SH2ZJ2H3313M31AM2Z333Z12Z3331C320N31AG318W33BM310F310731IA33BV33C1319633CJ33CB2U5312033BV319E330T31TR313H32462SH319M25C2YR318B2ZS33ZU2V3321K339Q33YL25C240319Z2ZS340331IR32B031YQ33YU319W2932ZQ31R92ZS340D2Z32ZU2752ZW31QP31AH3324332B2KU31S5310F312A33ZK33AE32ZM33ZW33FH312O333R33A831B233FO2ZS2RN333X31B931C831BC2VI31BF2VN2782H931BJ33LI2V331MN31B231NB2Z3333W2LA33L22SH28Q335K33V627933V832DP32X833T831C7331J32Y032XJ2AR24U3381342231IR33K732EN2RH32KK32TQ32DN29Q335I2VA335832Y531UH2AR335J322X334C313H2V832BI31BX31D525U2A831EG32KK3393322E314Y29Q31P6326633HB31333176338R2XB32XZ31DL33L833922W1342I31S132CU316N31UM338S2F031BQ32C2342P2R92VL2GL341R2UD31SD28Q2F0341T31UI341T31UP342P27Q25U32AS2CJ2XK335F31DL33H9342Y33VI2S933LE31D531PR31482UM31MH2AM3434312T2TL338V317O343D32XY31TW344332JN33L832Y4334C339B27933FQ2Z6339E31ET33VC2VO3390339K2Y22W033BL339N2AA339R314Y2B933VO339V33VQ339X317E31VL33VV33A2330Y31OL2UM2WX342Z2Y1339U317E33WY330B319K319T33AF2V32YD330Y2V833AJ31FT33AM31QK33AL310O2YO2VN2WX22V315Q31PV31XJ33AW31QI33DV317E33B12VS2X633WY33B525C21F316833B8310L33BA2YD2YD31TL332F33C433BF2AM2ZA33BI339031ZU31IB31HX33BO31QL33CK31I02VI33BV2H533BX330F33CJ33C4342U347F31AM33C631ZO33C931I632YP322Q33CD33ZH33BN33CK33CG341D314Y312A319V33CO31M5340031M531A431KA31AD348231AD1T2YW34011G33ED2ZS348A31IR348731YQ33D8318Z2Z833DY2H332EF2IW1L33DG31AD348O318T33DN33F331K131JS2Z6310733DT33BV33E033DY346F2KI31S033CM312A33BV33E4347R31FI313H1A310W2GV2H91W348B279349H31IR33E933EG332G33YF25C33DL34832Z3349R33D733CK2H3349P21333EV31AD349Z348S33F2316W2KE348W333F31ZE2KE340R349632YP2UZ33FE31TX349M31AW31LL333R33FL334B341227921C31B72ZK33FT27533FV319B33FY2Y123633G231HQ2UZ33G5334B33G82ZS33EF2LA33GC341O2WY344V31UI344V31UT33HH31DB33GN33H8314Y31NR33VU345N31V033HG2VO33GZ31332FI33H934BF342U34BI33H934BK33HC34BM347Z2A934BF34BQ2R733XB33HN2TL22F33HR27534C933HU3255276326J33J22E433J432MU31EO32MP34CI33MF24Y23L24K2DY32QL24732OZ2CV2XK34CU32PU23Q32Q032N433MN32N833MQ32ND32NF32NH32NJ32NL32NN33OK25C23L24U2F632Q02AK327H33OU2ET33OX33HY32QJ33P02F532QN2N433P532QQ2FG33P932QU33PC32QX33PF32R033PI32R333PK32IZ342227522G27934E834E72FD34EA25C34ED34EF34E9279337S337U27922J34EL2FD34EM27534EP25C34ER34ET34EN34EQ34EV34ES34EX34EU34EW34F134EY34F234F034F334F634F534F834EZ34FA34F434FB34F734FD34F934F22I734FG34FE34FC34FL34FK34F62A934FJ34FQ34FF34FS34FH34FT2AA34FR34FM34ER2P134FJ34G0279337X2752QQ27534E632HD322Q31NB31K62GP32ET31AD32XB2ZS322C32HG33C231NB31UO31Q62RZ33S332CH3363275311I31TX34GT31E032DK2TK338U31EK32Y22W1344R2TV2TO2W132Y8316N32YB313E33H731ML33GQ34HA314E29331MB32YL33HE33VZ314Y31F332YQ31EO2GE2T5312A32YV34C133WA31O633S632Z231G332Z42X42VD32Z72VL2VN2T531QU31OY2T52GP32ZF322W2KI32ZJ2VV314Z34HO2W72T9311U31WR315L27833BA31FG2B92WM2V431H72FI33XE2WU33XC341F33052W12XI330A2Y733BG2X9338S330E31PW33H2330734HK330Z33XJ33BJ2XR338S2XU330U2Y733BZ310O2XW2G8330W2XL33VY2Y32YA314Y2YD33B1317V31YB3402311D31LQ33D02VO3406310O34JZ3331330K318E310O289331T322O331W31KX331K32HW333A33YB31AS333E332733BW31XZ332B31I42H72892U5346S34JD318X330933AB34AT33EA2X6331E33YI331L31TP31QK31KH25C332S332Z33OL331K311431J5333228931YI34082ZK2Z334LG2Z332TQ34KG312131AK333E333G2H334KQ347W310L2TN333L31TX331E333P31XJ2V3340Y341131LP2ZS2AL333X34I1333Z34BR2VI33WM346F3346343E3349341F313G34M42LO31BU33VB2CO32E02W132FA34CE2GO2ER34CH32MR34CO33O225C33MI32MZ32N133ML32N532N733MP32NB34D633MT34D933MW34DC34DE34DG33IT24K34DJ2ER33OV32QF2EX34DN32QK33P134DR2KB34DT2AM33P832QT33PB32QW33PE32QZ33PH32R22AA32R42G52LP275338H34O427922S34O727922T34OA2FD34OB27534OE25C34OG34OI34OC34OF34OK34OH34OM34OJ34OL34OQ34ON34OR34OP34OS34OV34OU34OX34OO34OZ34OT34P034OW34P234OY34OR2I734P534P334P134P634P434PC34PA34P934PF34P82A934PH34PD2AA34P834PM326G34PE34OG2P134OG22U2FD34PT27534692R234MK331J34GK324U34B92752LN338C34Q5344W31EH313P34GY3231322P34H134H433LJ34H334H631EP34IZ33VM33WV34HB34MA31M533LD34HF341F34HI2VO345N31EX33W334HK34HP319B34HS2V232YY34HV32Z132KJ34M832Z5333Y2B934I32VO33WO34I731HC31OY314T315Y2W02TT316228Q2XK32ZN32WJ346O33WK2VO34IN34IR31S131FG314R34IT2AM34IV2AA3303330N344R33082Y634J3330C2X82VJ34J734IX330I33XI330T3390316Z34JF330Q34JO34JJ33Y2345334JN330Z330Y34JQ33CL2YD31O92VS33YE2YY293310Y331931AD34SZ340B25C33YR34L133YR2Z334T2311K31U131J5318F337P318M2ZA33Z131SJ2L431AF3322316W31HE332631AM2H52V6318Y349531IA28Q34KR310L2V634KU310R3230329V349E2Y732IJ332Q2Z334U531AD33ZX312E3118311O29334K234L834JX3407331M333228Q34UD32RC333731AD340G32SY34LM333C312333X734LQ314Z33FA332F2GN34LW31UI34UA2VI31XY34M133A3333U31UI3414328W333Y31303340313431GA2T9347U2V3335B313C334A31B232Y0341K34ML31E73221334J2LL33KL27934VU31AD34Q734MO34GZ25C33M72AA');

local BitXOR = bit and bit.bxor or function(a,b)
    local p,c=1,0
    while a>0 and b>0 do
        local ra,rb=a%2,b%2
        if ra~=rb then c=c+p end
        a,b,p=(a-ra)/2,(b-rb)/2,p*2
    end
    if a<b then a=b end
    while a>0 do
        local ra=a%2
        if ra>0 then c=c+p end
        a,p=(a-ra)/2,p*2
    end
    return c
end

local function gBit(Bit, Start, End)
	if End then
		local Res = (Bit / 2 ^ (Start - 1)) % 2 ^ ((End - 1) - (Start - 1) + 1);
		return Res - Res % 1;
	else
		local Plc = 2 ^ (Start - 1);
        return (Bit % (Plc + Plc) >= Plc) and 1 or 0;
	end;
end;

local Pos = 1;

local function gBits32()
    local W, X, Y, Z = Byte(ByteString, Pos, Pos + 3);

	W = BitXOR(W, 192)
	X = BitXOR(X, 192)
	Y = BitXOR(Y, 192)
	Z = BitXOR(Z, 192)

    Pos	= Pos + 4;
    return (Z*16777216) + (Y*65536) + (X*256) + W;
end;

local function gBits8()
    local F = BitXOR(Byte(ByteString, Pos, Pos), 192);
    Pos = Pos + 1;
    return F;
end;

local function gBits16()
    local W, X = Byte(ByteString, Pos, Pos + 2);

	W = BitXOR(W, 192)
	X = BitXOR(X, 192)

    Pos	= Pos + 2;
    return (X*256) + W;
end;

local function gFloat()
	local Left = gBits32();
	local Right = gBits32();
	local IsNormal = 1;
	local Mantissa = (gBit(Right, 1, 20) * (2 ^ 32))
					+ Left;
	local Exponent = gBit(Right, 21, 31);
	local Sign = ((-1) ^ gBit(Right, 32));
	if (Exponent == 0) then
		if (Mantissa == 0) then
			return Sign * 0; -- +-0
		else
			Exponent = 1;
			IsNormal = 0;
		end;
	elseif (Exponent == 2047) then
        return (Mantissa == 0) and (Sign * (1 / 0)) or (Sign * (0 / 0));
	end;
	return LDExp(Sign, Exponent - 1023) * (IsNormal + (Mantissa / (2 ^ 52)));
end;

local gSizet = gBits32;
local function gString(Len)
    local Str;
    if (not Len) then
        Len = gSizet();
        if (Len == 0) then
            return '';
        end;
    end;

    Str	= Sub(ByteString, Pos, Pos + Len - 1);
    Pos = Pos + Len;

	local FStr = {}
	for Idx = 1, #Str do
		FStr[Idx] = Char(BitXOR(Byte(Sub(Str, Idx, Idx)), 192))
	end

    return Concat(FStr);
end;

local gInt = gBits32;
local function _R(...) return {...}, Select('#', ...) end

local function Deserialize()
    local Instrs = {};
    local Functions = {};
	local Lines = {};
    local Chunk = 
	{
		Instrs,
		Functions,
		nil,
		Lines
	};
	local ConstCount = gBits32()
    local Consts = {}

	for Idx=1, ConstCount do 
		local Type =gBits8();
		local Cons;
	
		if(Type==2) then Cons = (gBits8() ~= 0);
		elseif(Type==0) then Cons = gFloat();
		elseif(Type==1) then Cons = gString();
		end;
		
		Consts[Idx] = Cons;
	end;
for Idx=1,gBits32() do Lines[Idx]=gBits32();end;
                            local function createInstruction(instructionType)
                                local instruction = {gBits16(), gBits16(), nil, nil}

                                if instructionType == 0 then 
                                    instruction[3] = gBits16()
                                    instruction[4] = gBits16()
                                elseif instructionType == 1 then 
                                    instruction[3] = gBits32()
                                elseif instructionType == 2 then 
                                    instruction[3] = gBits32() - (2 ^ 16)
                                elseif instructionType == 3 then 
                                    instruction[3] = gBits32() - (2 ^ 16)
                                    instruction[4] = gBits16()
                                else
                                    error("Invalid instruction type: " .. tostring(instructionType))
                                end

                                return instruction
                            end

                            local function applyMask(instruction, mask)
                                if gBit(mask, 1, 1) == 1 then 
                                    instruction[2] = Consts[instruction[2]] 
                                end
                                if gBit(mask, 2, 2) == 1 then 
                                    instruction[3] = Consts[instruction[3]] 
                                end
                                if gBit(mask, 3, 3) == 1 then 
                                    instruction[4] = Consts[instruction[4]] 
                                end
                            end

                            for idx = 1, gBits32() do 
                                local descriptor = gBits8()

                                if gBit(descriptor, 1, 1) == 0 then
                                    local instructionType = gBit(descriptor, 2, 3)
                                    local mask = gBit(descriptor, 4, 6)

                                    local instruction = createInstruction(instructionType)

                                    applyMask(instruction, mask)

                                    Instrs[idx] = instruction
                                end
                            end
                            ;for Idx=1,gBits32() do Functions[Idx-1]=Deserialize();end;Chunk[3] = gBits8();return Chunk;end;
local PCall = pcall
local function Wrap(Chunk, Upvalues, Env)
	local Instr = Chunk[1];
	local Proto = Chunk[2];
	local Params = Chunk[3];

	return function(...)
		local InstrPoint = 1;
		local Top = -1;

		local Args = {...};
		local PCount = Select('#', ...) - 1;

		local function Loop()
			local Instr  = Instr; 
			local Const  = Const; 
			local Proto  = Proto; 
			local Params = Params;

			local _R = _R
			local Vararg = {};

			local Lupvals	= {};
			local Stk		= {};
	
			for Idx = 0, PCount do
				if (Idx >= Params) then
					Vararg[Idx - Params] = Args[Idx + 1];
				else
					Stk[Idx] = Args[Idx + 1];
				end;
			end;
	
			local Varargsz = PCount - Params + 1

			local Inst;
			local Enum;	

			while true do
				Inst		= Instr[InstrPoint];
				Enum		= Inst[1];if Enum <= 71 then if Enum <= 35 then if Enum <= 17 then if Enum <= 8 then if Enum <= 3 then if Enum <= 1 then if Enum > 0 then 
do return Stk[Inst[2]] end
else Stk[Inst[2]]=Stk[Inst[3]][Stk[Inst[4]]];end; elseif Enum == 2 then local B;local A;Stk[Inst[2]][Inst[3]] = Inst[4];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]][Inst[3]] = Inst[4];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]][Inst[3]] = Inst[4];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Env[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];A=Inst[2];B=Stk[Inst[3]];Stk[A+1]=B;Stk[A]=B[Inst[4]];else local VA;local A;Stk[Inst[2]]=Upvalues[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];A=Inst[2];Top=A+Varargsz-1;for Idx=A,Top do VA=Vararg[Idx-A];Stk[Idx]=VA;end;InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];
A= Inst[2];
do return Stk[A](Unpack(Stk, A + 1, Top)) end;
InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];
A= Inst[2]; 
do return Unpack(Stk, A, Top) end;InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];do return end;end; elseif Enum <= 5 then if Enum > 4 then Stk[Inst[2]]=Stk[Inst[3]][Inst[4]];else Stk[Inst[2]]=#Stk[Inst[3]];end; elseif Enum <= 6 then local B=Stk[Inst[4]];if not B then InstrPoint=InstrPoint+1;else Stk[Inst[2]]=B;InstrPoint=Inst[3];end; elseif Enum > 7 then Stk[Inst[2]]=Env[Inst[3]];else for Idx=Inst[2],Inst[3] do Stk[Idx]=nil;end;end; elseif Enum <= 12 then if Enum <= 10 then if Enum > 9 then Stk[Inst[2]] = Stk[Inst[3]] + Inst[4];else Stk[Inst[2]]=(Inst[3]~=0);end; elseif Enum == 11 then local A=Inst[2];local Cls={};for Idx=1,#Lupvals do local List=Lupvals[Idx];for Idz=0,#List do local Upv=List[Idz];local NStk=Upv[1];local Pos=Upv[2]; if NStk==Stk and Pos>=A then Cls[Pos]=NStk[Pos];Upv[1]=Cls;end;end;end;else Stk[Inst[2]] = Stk[Inst[3]] / Inst[4];end; elseif Enum <= 14 then if Enum == 13 then local A=Inst[2];local B=Stk[Inst[3]];Stk[A+1]=B;Stk[A]=B[Inst[4]];else local B=Stk[Inst[4]];if not B then InstrPoint=InstrPoint+1;else Stk[Inst[2]]=B;InstrPoint=Inst[3];end;end; elseif Enum <= 15 then if Stk[Inst[2]] then InstrPoint=InstrPoint + 1; else InstrPoint = Inst[3]; end; elseif Enum > 16 then Stk[Inst[2]] = Stk[Inst[3]] / Inst[4];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]]-Stk[Inst[4]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Stk[Inst[3]] / Inst[4];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Stk[Inst[3]] * Inst[4];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];InstrPoint=Inst[3];else 
local A = Inst[2];
local T = Stk[A];
for Idx = A + 1, Inst[3] do 
	Insert(T, Stk[Idx])
end;end; elseif Enum <= 26 then if Enum <= 21 then if Enum <= 19 then if Enum > 18 then Stk[Inst[2]][Stk[Inst[3]]]=Stk[Inst[4]];else 
local A = Inst[2];
local T = Stk[A];
for Idx = A + 1, Inst[3] do 
	Insert(T, Stk[Idx])
end;end; elseif Enum == 20 then if(Stk[Inst[2]] < Stk[Inst[4]])then InstrPoint=InstrPoint+1;else InstrPoint=Inst[3];end;else if (Stk[Inst[2]]<Stk[Inst[4]])then InstrPoint=Inst[3]; else InstrPoint=InstrPoint+1; end;end; elseif Enum <= 23 then if Enum > 22 then Stk[Inst[2]]=(Inst[3]~=0);InstrPoint=InstrPoint+1;else Stk[Inst[2]][Inst[3]] = Inst[4];end; elseif Enum <= 24 then Stk[Inst[2]]=Stk[Inst[3]]-Stk[Inst[4]]; elseif Enum > 25 then Stk[Inst[2]] = Inst[3];else Stk[Inst[2]][Stk[Inst[3]]]=Stk[Inst[4]];end; elseif Enum <= 30 then if Enum <= 28 then if Enum > 27 then 
local A = Inst[2]
Stk[A](Unpack(Stk, A + 1, Inst[3]))
else 
do return Stk[Inst[2]] end
end; elseif Enum == 29 then local A=Inst[2];local Cls={};for Idx=1,#Lupvals do local List=Lupvals[Idx];for Idz=0,#List do local Upv=List[Idz];local NStk=Upv[1];local Pos=Upv[2]; if NStk==Stk and Pos>=A then Cls[Pos]=NStk[Pos];Upv[1]=Cls;end;end;end;else if(Stk[Inst[2]]~=Stk[Inst[4]])then InstrPoint=InstrPoint+1;else InstrPoint=Inst[3];end;end; elseif Enum <= 32 then if Enum == 31 then local Step;local Index;local A;Stk[Inst[2]] = Inst[3];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Inst[3];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Env[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Inst[4]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Env[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Inst[4]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]={};InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Inst[3];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Inst[3];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Inst[3];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];
A= Inst[2];
Index= Stk[A]
Step= Stk[A + 2];
if (Step > 0) then 
	if (Index > Stk[A+1]) then
		InstrPoint = Inst[3];
	else
		Stk[A+3] = Index;
	end
elseif (Index < Stk[A+1]) then
	InstrPoint = Inst[3];
else
	Stk[A+3] = Index;
end
else 
local A = Inst[2]
Stk[A](Unpack(Stk, A + 1, Inst[3]))
end; elseif Enum <= 33 then Stk[Inst[2]] = Stk[Inst[3]] * Inst[4]; elseif Enum > 34 then 
local A = Inst[2]
Stk[A] = Stk[A](Stk[A + 1]) 
else local A;Stk[Inst[2]] = Stk[Inst[3]] % Inst[4];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Stk[Inst[3]] + Inst[4];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];
A= Inst[2]
Stk[A] = Stk[A](Unpack(Stk, A + 1, Inst[3])) 
InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Stk[Inst[4]]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];
A= Inst[2]
Stk[A] = Stk[A](Unpack(Stk, A + 1, Inst[3])) 
InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Stk[Inst[4]]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Inst[3];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Inst[3];end; elseif Enum <= 53 then if Enum <= 44 then if Enum <= 39 then if Enum <= 37 then if Enum == 36 then 
local A = Inst[2]; 
do return Unpack(Stk, A, Top) end;else local Step;local Index;local B;local A;Stk[Inst[2]]=Stk[Inst[3]][Inst[4]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];A=Inst[2];B=Stk[Inst[3]];Stk[A+1]=B;Stk[A]=B[Inst[4]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Inst[3];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Inst[3];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Env[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Inst[4]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Env[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Inst[4]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]={};InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Inst[3];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Inst[3];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Inst[3];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];
A= Inst[2];
Index= Stk[A]
Step= Stk[A + 2];
if (Step > 0) then 
	if (Index > Stk[A+1]) then
		InstrPoint = Inst[3];
	else
		Stk[A+3] = Index;
	end
elseif (Index < Stk[A+1]) then
	InstrPoint = Inst[3];
else
	Stk[A+3] = Index;
end
end; elseif Enum == 38 then Stk[Inst[2]]=#Stk[Inst[3]];else do return end;end; elseif Enum <= 41 then if Enum == 40 then Stk[Inst[2]]=Wrap(Proto[Inst[3]],nil,Env);else local B=Inst[3];local K=Stk[B] for Idx=B+1,Inst[4] do K=K..Stk[Idx];end;Stk[Inst[2]]=K;end; elseif Enum <= 42 then local A=Inst[2];Top=A+Varargsz-1;for Idx=A,Top do local VA=Vararg[Idx-A];Stk[Idx]=VA;end; elseif Enum > 43 then Stk[Inst[2]] = Stk[Inst[3]] / Inst[4];else do return end;end; elseif Enum <= 48 then if Enum <= 46 then if Enum == 45 then Stk[Inst[2]]=Stk[Inst[3]]*Stk[Inst[4]];else Stk[Inst[2]]=Stk[Inst[3]]+Stk[Inst[4]];end; elseif Enum > 47 then 
local A = Inst[2];
local Index = Stk[A]
local Step = Stk[A + 2];
if (Step > 0) then 
	if (Index > Stk[A+1]) then
		InstrPoint = Inst[3];
	else
		Stk[A+3] = Index;
	end
elseif (Index < Stk[A+1]) then
	InstrPoint = Inst[3];
else
	Stk[A+3] = Index;
end
else Stk[Inst[2]]();end; elseif Enum <= 50 then if Enum == 49 then local A=Inst[2];Top=A+Varargsz-1;for Idx=A,Top do local VA=Vararg[Idx-A];Stk[Idx]=VA;end;else Stk[Inst[2]]=Stk[Inst[3]][Stk[Inst[4]]];end; elseif Enum <= 51 then Stk[Inst[2]] = Inst[3]; elseif Enum > 52 then local Results;local Edx;local Results,Limit;local B;local A;
A= Inst[2]
Stk[A] = Stk[A](Unpack(Stk, A + 1, Inst[3])) 
InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]]*Stk[Inst[4]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]][Inst[3]] = Stk[Inst[4]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Env[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Upvalues[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Inst[4]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];A=Inst[2];B=Stk[Inst[3]];Stk[A+1]=B;Stk[A]=B[Inst[4]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];
A= Inst[2]
Results,Limit= _R(Stk[A](Stk[A + 1]))
Top = Limit + A - 1
Edx= 0;
for Idx = A, Top do 
	Edx = Edx + 1;
	Stk[Idx] = Results[Edx];
end;
InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];
A= Inst[2]
Results= { Stk[A](Unpack(Stk, A + 1, Top)) };
Edx= 0;
for Idx = A, Inst[4] do 
	Edx = Edx + 1;
	Stk[Idx] = Results[Edx];
end
InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];InstrPoint=Inst[3];else Stk[Inst[2]] = Stk[Inst[3]] + Inst[4];end; elseif Enum <= 62 then if Enum <= 57 then if Enum <= 55 then if Enum > 54 then local NewProto=Proto[Inst[3]];local NewUvals;local Indexes={};NewUvals=Setmetatable({},{__index=function(_,Key)local Val=Indexes[Key];return Val[1][Val[2]];end,__newindex=function(_,Key,Value)local Val=Indexes[Key] Val[1][Val[2]]=Value;end;});for Idx=1,Inst[4] do InstrPoint=InstrPoint+1;local Mvm=Instr[InstrPoint];if Mvm[1]==71 then Indexes[Idx-1]={Stk,Mvm[3]};else Indexes[Idx-1]={Upvalues,Mvm[3]};end;Lupvals[#Lupvals+1]=Indexes;end;Stk[Inst[2]]=Wrap(NewProto,NewUvals,Env);else 
local A = Inst[2]
local Results, Limit = _R(Stk[A](Stk[A + 1]))
Top = Limit + A - 1
local Edx = 0;
for Idx = A, Top do 
	Edx = Edx + 1;
	Stk[Idx] = Results[Edx];
end;
end; elseif Enum > 56 then if(Inst[2] < Stk[Inst[4]])then InstrPoint=InstrPoint+1;else InstrPoint=Inst[3];end;else Env[Inst[3]] = Stk[Inst[2]];end; elseif Enum <= 59 then if Enum == 58 then 
local A = Inst[2]
local Results, Limit = _R(Stk[A]())
Top = Limit + A - 1
local Edx = 0;
for Idx = A, Top do 
	Edx = Edx + 1;
	Stk[Idx] = Results[Edx];
end;
else Stk[Inst[2]][Inst[3]] = Inst[4];end; elseif Enum <= 60 then local Results;local Edx;local Results,Limit;local B;local A;Stk[Inst[2]]=Env[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Inst[4]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Inst[3];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Upvalues[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Stk[Inst[3]] * Inst[4];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]]*Stk[Inst[4]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Inst[3];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];
A= Inst[2]
Stk[A] = Stk[A](Unpack(Stk, A + 1, Inst[3])) 
InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]]+Stk[Inst[4]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]][Inst[3]] = Stk[Inst[4]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Env[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];A=Inst[2];B=Stk[Inst[3]];Stk[A+1]=B;Stk[A]=B[Inst[4]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];
A= Inst[2]
Results,Limit= _R(Stk[A](Stk[A + 1]))
Top = Limit + A - 1
Edx= 0;
for Idx = A, Top do 
	Edx = Edx + 1;
	Stk[Idx] = Results[Edx];
end;
InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];
A= Inst[2]
Results= { Stk[A](Unpack(Stk, A + 1, Top)) };
Edx= 0;
for Idx = A, Inst[4] do 
	Edx = Edx + 1;
	Stk[Idx] = Results[Edx];
end
InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];InstrPoint=Inst[3]; elseif Enum > 61 then local B=Inst[3];local K=Stk[B] for Idx=B+1,Inst[4] do K=K..Stk[Idx];end;Stk[Inst[2]]=K;else Stk[Inst[2]]=Stk[Inst[3]];end; elseif Enum <= 66 then if Enum <= 64 then if Enum > 63 then if (Inst[2] < Stk[Inst[4]]) then InstrPoint=Inst[3]; else InstrPoint=InstrPoint+1; end;else 
local A = Inst[2];
do return Stk[A](Unpack(Stk, A + 1, Top)) end;
end; elseif Enum > 65 then 
local A = Inst[2];
local Index = Stk[A]
local Step = Stk[A + 2];
if (Step > 0) then 
	if (Index > Stk[A+1]) then
		InstrPoint = Inst[3];
	else
		Stk[A+3] = Index;
	end
elseif (Index < Stk[A+1]) then
	InstrPoint = Inst[3];
else
	Stk[A+3] = Index;
end
else 
local A = Inst[2]
Stk[A] = Stk[A](Unpack(Stk, A + 1, Inst[3])) 
end; elseif Enum <= 68 then if Enum == 67 then Stk[Inst[2]]=Stk[Inst[3]]-Stk[Inst[4]];else 
local A = Inst[2];
local C = Inst[4];
local CB = A + 2
local Result = {Stk[A](Stk[A + 1],Stk[CB])};
for Idx = 1, C do 
	Stk[CB + Idx] = Result[Idx];
end;
local R = Result[1]
if R then 
	Stk[CB] = R 
	InstrPoint = Inst[3];
else
	InstrPoint = InstrPoint + 1;
end;end; elseif Enum <= 69 then Stk[Inst[2]]=Upvalues[Inst[3]]; elseif Enum == 70 then Stk[Inst[2]]=Stk[Inst[3]][Inst[4]];else Stk[Inst[2]]=Stk[Inst[3]];end; elseif Enum <= 107 then if Enum <= 89 then if Enum <= 80 then if Enum <= 75 then if Enum <= 73 then if Enum == 72 then Stk[Inst[2]] = Stk[Inst[3]] / Inst[4];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]]-Stk[Inst[4]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Stk[Inst[3]] / Inst[4];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Stk[Inst[3]] * Inst[4];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];InstrPoint=Inst[3];else if(Stk[Inst[2]] < Stk[Inst[4]])then InstrPoint=InstrPoint+1;else InstrPoint=Inst[3];end;end; elseif Enum > 74 then local Step;local Index;local A;Stk[Inst[2]] = Inst[3];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Inst[3];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Env[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Inst[4]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Env[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Inst[4]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]={};InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Inst[3];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Inst[3];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Inst[3];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];
A= Inst[2];
Index= Stk[A]
Step= Stk[A + 2];
if (Step > 0) then 
	if (Index > Stk[A+1]) then
		InstrPoint = Inst[3];
	else
		Stk[A+3] = Index;
	end
elseif (Index < Stk[A+1]) then
	InstrPoint = Inst[3];
else
	Stk[A+3] = Index;
end
else Stk[Inst[2]] = Stk[Inst[3]] / Inst[4];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]]-Stk[Inst[4]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Stk[Inst[3]] / Inst[4];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Stk[Inst[3]] * Inst[4];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];InstrPoint=Inst[3];end; elseif Enum <= 77 then if Enum == 76 then 
local A = Inst[2]
local Results, Limit = _R(Stk[A](Stk[A + 1]))
Top = Limit + A - 1
local Edx = 0;
for Idx = A, Top do 
	Edx = Edx + 1;
	Stk[Idx] = Results[Edx];
end;
else if Stk[Inst[2]] then InstrPoint=InstrPoint + 1; else InstrPoint = Inst[3]; end;end; elseif Enum <= 78 then local Step;local Index;local A;Stk[Inst[2]] = Inst[3];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Inst[3];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Env[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Inst[4]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Env[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Inst[4]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]={};InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Inst[3];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Inst[3];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Inst[3];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];
A= Inst[2];
Index= Stk[A]
Step= Stk[A + 2];
if (Step > 0) then 
	if (Index > Stk[A+1]) then
		InstrPoint = Inst[3];
	else
		Stk[A+3] = Index;
	end
elseif (Index < Stk[A+1]) then
	InstrPoint = Inst[3];
else
	Stk[A+3] = Index;
end
 elseif Enum == 79 then local NewProto=Proto[Inst[3]];local NewUvals;local Indexes={};NewUvals=Setmetatable({},{__index=function(_,Key)local Val=Indexes[Key];return Val[1][Val[2]];end,__newindex=function(_,Key,Value)local Val=Indexes[Key] Val[1][Val[2]]=Value;end;});for Idx=1,Inst[4] do InstrPoint=InstrPoint+1;local Mvm=Instr[InstrPoint];if Mvm[1]==71 then Indexes[Idx-1]={Stk,Mvm[3]};else Indexes[Idx-1]={Upvalues,Mvm[3]};end;Lupvals[#Lupvals+1]=Indexes;end;Stk[Inst[2]]=Wrap(NewProto,NewUvals,Env);else Stk[Inst[2]]={};end; elseif Enum <= 84 then if Enum <= 82 then if Enum > 81 then local A;Stk[Inst[2]] = Stk[Inst[3]] % Inst[4];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Stk[Inst[3]] + Inst[4];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];
A= Inst[2]
Stk[A] = Stk[A](Unpack(Stk, A + 1, Inst[3])) 
InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Stk[Inst[4]]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];
A= Inst[2]
Stk[A] = Stk[A](Unpack(Stk, A + 1, Inst[3])) 
InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Stk[Inst[4]]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Inst[3];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Inst[3];else Stk[Inst[2]]=Stk[Inst[3]]+Stk[Inst[4]];end; elseif Enum > 83 then if(Stk[Inst[2]]==Stk[Inst[4]])then InstrPoint=InstrPoint+1;else InstrPoint=Inst[3];end;else Stk[Inst[2]]=Stk[Inst[3]][Inst[4]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Env[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Inst[4]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Inst[4]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];if(Stk[Inst[2]]==Stk[Inst[4]])then InstrPoint=InstrPoint+1;else InstrPoint=Inst[3];end;end; elseif Enum <= 86 then if Enum == 85 then InstrPoint=Inst[3];else Stk[Inst[2]]();end; elseif Enum <= 87 then local A=Inst[2];local B=Stk[Inst[3]];Stk[A+1]=B;Stk[A]=B[Inst[4]]; elseif Enum > 88 then Stk[Inst[2]]=Env[Inst[3]];else if(Stk[Inst[2]] == Inst[4])then InstrPoint=InstrPoint+1;else InstrPoint=Inst[3];end;end; elseif Enum <= 98 then if Enum <= 93 then if Enum <= 91 then if Enum == 90 then Stk[Inst[2]]=Stk[Inst[3]][Inst[4]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Env[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Inst[4]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Inst[4]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];if(Stk[Inst[2]]~=Stk[Inst[4]])then InstrPoint=InstrPoint+1;else InstrPoint=Inst[3];end;else local A;Stk[Inst[2]]=Stk[Inst[3]][Inst[4]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Inst[4]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Inst[4]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];
A= Inst[2]
Stk[A] = Stk[A](Unpack(Stk, A + 1, Inst[3])) 
InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];InstrPoint=Inst[3];end; elseif Enum == 92 then InstrPoint=Inst[3];else Stk[Inst[2]] = Stk[Inst[3]] / Inst[4];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]]-Stk[Inst[4]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Stk[Inst[3]] / Inst[4];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Stk[Inst[3]] * Inst[4];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];InstrPoint=Inst[3];end; elseif Enum <= 95 then if Enum == 94 then Stk[Inst[2]]=Wrap(Proto[Inst[3]],nil,Env);else Stk[Inst[2]]=Upvalues[Inst[3]];end; elseif Enum <= 96 then local A;Stk[Inst[2]]=Stk[Inst[3]][Inst[4]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Inst[3];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Inst[3];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Inst[3];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];
A= Inst[2]
Stk[A] = Stk[A](Unpack(Stk, A + 1, Inst[3])) 
InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]][Inst[3]] = Stk[Inst[4]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Env[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Inst[4]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Inst[3];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Inst[3];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Inst[3];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];
A= Inst[2]
Stk[A] = Stk[A](Unpack(Stk, A + 1, Inst[3])) 
InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]][Inst[3]] = Stk[Inst[4]]; elseif Enum == 97 then if(Stk[Inst[2]]==Stk[Inst[4]])then InstrPoint=InstrPoint+1;else InstrPoint=Inst[3];end;else Stk[Inst[2]]=(Inst[3]~=0);end; elseif Enum <= 102 then if Enum <= 100 then if Enum > 99 then 
local A = Inst[2]
Stk[A] = Stk[A](Unpack(Stk, A + 1, Inst[3])) 
else 
local A = Inst[2]
local Results = { Stk[A](Unpack(Stk, A + 1, Top)) };
local Edx = 0;
for Idx = A, Inst[4] do 
	Edx = Edx + 1;
	Stk[Idx] = Results[Edx];
end
end; elseif Enum == 101 then local A;Stk[Inst[2]]=Env[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Inst[4]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Inst[3];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Inst[3];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Inst[3];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];
A= Inst[2]
Stk[A] = Stk[A](Unpack(Stk, A + 1, Inst[3])) 
InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]]*Stk[Inst[4]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Upvalues[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Inst[4]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Inst[4]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];
A= Inst[2]
Stk[A] = Stk[A](Unpack(Stk, A + 1, Inst[3])) 
InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];else 
local A = Inst[2];
local Step = Stk[A + 2];
local Index = Stk[A] + Step;
Stk[A] = Index;
if (Step > 0) then 
	if (Index <= Stk[A+1]) then
		InstrPoint = Inst[3];
		Stk[A+3] = Index;
	end
elseif (Index >= Stk[A+1]) then
	InstrPoint = Inst[3];
	Stk[A+3] = Index;
end
end; elseif Enum <= 104 then if Enum == 103 then local B;local A;
A= Inst[2]
Stk[A](Unpack(Stk, A + 1, Inst[3]))
InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=(Inst[3]~=0);InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=(Inst[3]~=0);InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Inst[3];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Env[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];A=Inst[2];B=Stk[Inst[3]];Stk[A+1]=B;Stk[A]=B[Inst[4]];else Stk[Inst[2]]=Stk[Inst[3]] - Inst[4];end; elseif Enum <= 105 then local T;local B;local A;Stk[Inst[2]]=Stk[Inst[3]][Inst[4]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Inst[4]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Stk[Inst[3]] * Inst[4];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];
A= Inst[2]
Stk[A] = Stk[A](Unpack(Stk, A + 1, Inst[3])) 
InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Env[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];A=Inst[2];B=Stk[Inst[3]];Stk[A+1]=B;Stk[A]=B[Inst[4]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]={};InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Env[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Inst[4]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Env[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];
A= Inst[2];
T= Stk[A];
for Idx = A + 1, Inst[3] do 
	Insert(T, Stk[Idx])
end; elseif Enum == 106 then if not Stk[Inst[2]] then InstrPoint=InstrPoint+1;else InstrPoint=Inst[3];end;else Stk[Inst[2]]=Env[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Inst[4]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Inst[4]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]={};InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]][Inst[3]] = Inst[4];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]][Inst[3]] = Inst[4];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]][Inst[3]] = Inst[4];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]][Inst[3]] = Inst[4];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]][Inst[3]] = Inst[4];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]][Inst[3]] = Inst[4];end; elseif Enum <= 125 then if Enum <= 116 then if Enum <= 111 then if Enum <= 109 then if Enum > 108 then Stk[Inst[2]] = Stk[Inst[3]] % Inst[4];else Top=Inst[2];end; elseif Enum == 110 then Stk[Inst[2]]=Stk[Inst[3]]*Stk[Inst[4]];else local A;Stk[Inst[2]] = Stk[Inst[3]] % Inst[4];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Stk[Inst[3]] + Inst[4];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];
A= Inst[2]
Stk[A] = Stk[A](Unpack(Stk, A + 1, Inst[3])) 
InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Stk[Inst[4]]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];
A= Inst[2]
Stk[A] = Stk[A](Unpack(Stk, A + 1, Inst[3])) 
InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Stk[Inst[4]]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Inst[3];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Inst[3];end; elseif Enum <= 113 then if Enum > 112 then local Step;local Index;local A;Stk[Inst[2]] = Inst[3];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Inst[3];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Env[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Inst[4]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Env[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Inst[4]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]={};InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Inst[3];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Inst[3];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Inst[3];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];
A= Inst[2];
Index= Stk[A]
Step= Stk[A + 2];
if (Step > 0) then 
	if (Index > Stk[A+1]) then
		InstrPoint = Inst[3];
	else
		Stk[A+3] = Index;
	end
elseif (Index < Stk[A+1]) then
	InstrPoint = Inst[3];
else
	Stk[A+3] = Index;
end
else local A;Stk[Inst[2]] = Stk[Inst[3]] % Inst[4];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Stk[Inst[3]] + Inst[4];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];
A= Inst[2]
Stk[A] = Stk[A](Unpack(Stk, A + 1, Inst[3])) 
InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Stk[Inst[4]]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];
A= Inst[2]
Stk[A] = Stk[A](Unpack(Stk, A + 1, Inst[3])) 
InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Stk[Inst[4]]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Inst[3];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Inst[3];end; elseif Enum <= 114 then Stk[Inst[2]]=Stk[Inst[3]] - Inst[4]; elseif Enum == 115 then if(Stk[Inst[2]]~=Stk[Inst[4]])then InstrPoint=InstrPoint+1;else InstrPoint=Inst[3];end;else if (Inst[2] < Stk[Inst[4]]) then InstrPoint=Inst[3]; else InstrPoint=InstrPoint+1; end;end; elseif Enum <= 120 then if Enum <= 118 then if Enum == 117 then if(Stk[Inst[2]] == Inst[4])then InstrPoint=InstrPoint+1;else InstrPoint=Inst[3];end;else Top=Inst[2];end; elseif Enum == 119 then local A;Stk[Inst[2]] = Stk[Inst[3]] % Inst[4];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Stk[Inst[3]] + Inst[4];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];
A= Inst[2]
Stk[A] = Stk[A](Unpack(Stk, A + 1, Inst[3])) 
InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Stk[Inst[4]]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];
A= Inst[2]
Stk[A] = Stk[A](Unpack(Stk, A + 1, Inst[3])) 
InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Stk[Inst[4]]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Inst[3];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Inst[3];else local A;Stk[Inst[2]]=Stk[Inst[3]][Inst[4]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Inst[3];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Inst[3];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Inst[3];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];
A= Inst[2]
Stk[A] = Stk[A](Unpack(Stk, A + 1, Inst[3])) 
InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]][Inst[3]] = Stk[Inst[4]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Env[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Inst[4]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Inst[3];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Inst[3];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Inst[3];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];
A= Inst[2]
Stk[A] = Stk[A](Unpack(Stk, A + 1, Inst[3])) 
InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]][Inst[3]] = Stk[Inst[4]];end; elseif Enum <= 122 then if Enum > 121 then Stk[Inst[2]]={};else local Step;local Index;local A;Stk[Inst[2]] = Inst[3];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Inst[3];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Env[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Inst[4]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Env[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Inst[4]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]={};InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Inst[3];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Inst[3];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Inst[3];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];
A= Inst[2];
Index= Stk[A]
Step= Stk[A + 2];
if (Step > 0) then 
	if (Index > Stk[A+1]) then
		InstrPoint = Inst[3];
	else
		Stk[A+3] = Index;
	end
elseif (Index < Stk[A+1]) then
	InstrPoint = Inst[3];
else
	Stk[A+3] = Index;
end
end; elseif Enum <= 123 then 
local A = Inst[2];
do return Stk[A](Unpack(Stk, A + 1, Top)) end;
 elseif Enum > 124 then Stk[Inst[2]][Inst[3]] = Stk[Inst[4]];else 
local A = Inst[2];
local Step = Stk[A + 2];
local Index = Stk[A] + Step;
Stk[A] = Index;
if (Step > 0) then 
	if (Index <= Stk[A+1]) then
		InstrPoint = Inst[3];
		Stk[A+3] = Index;
	end
elseif (Index >= Stk[A+1]) then
	InstrPoint = Inst[3];
	Stk[A+3] = Index;
end
end; elseif Enum <= 134 then if Enum <= 129 then if Enum <= 127 then if Enum > 126 then 
local A = Inst[2]
local Results, Limit = _R(Stk[A]())
Top = Limit + A - 1
local Edx = 0;
for Idx = A, Top do 
	Edx = Edx + 1;
	Stk[Idx] = Results[Edx];
end;
else Stk[Inst[2]] = Stk[Inst[3]] / Inst[4];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]]-Stk[Inst[4]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Stk[Inst[3]] / Inst[4];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Stk[Inst[3]] * Inst[4];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];InstrPoint=Inst[3];end; elseif Enum == 128 then if(Inst[2] < Stk[Inst[4]])then InstrPoint=InstrPoint+1;else InstrPoint=Inst[3];end;else Stk[Inst[2]][Inst[3]] = Stk[Inst[4]];end; elseif Enum <= 131 then if Enum > 130 then local Edx;local Results,Limit;local A;Stk[Inst[2]]=Env[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Env[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Inst[4]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];
A= Inst[2]
Results,Limit= _R(Stk[A]())
Top = Limit + A - 1
Edx= 0;
for Idx = A, Top do 
	Edx = Edx + 1;
	Stk[Idx] = Results[Edx];
end;
InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];
A= Inst[2];
do return Stk[A](Unpack(Stk, A + 1, Top)) end;
InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];
A= Inst[2]; 
do return Unpack(Stk, A, Top) end;InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];do return end;else 
local A = Inst[2]
Stk[A] = Stk[A](Stk[A + 1]) 
end; elseif Enum <= 132 then 
local A = Inst[2]
local Results = { Stk[A](Unpack(Stk, A + 1, Top)) };
local Edx = 0;
for Idx = A, Inst[4] do 
	Edx = Edx + 1;
	Stk[Idx] = Results[Edx];
end
 elseif Enum > 133 then Stk[Inst[2]]=Stk[Inst[3]][Inst[4]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Stk[Inst[3]] * Inst[4];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]]*Stk[Inst[4]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Upvalues[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Upvalues[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Inst[4]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Inst[4]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Inst[4]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Env[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Inst[4]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Inst[4]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];if Stk[Inst[2]] then InstrPoint=InstrPoint + 1; else InstrPoint = Inst[3]; end;else 
local A = Inst[2];
local C = Inst[4];
local CB = A + 2
local Result = {Stk[A](Stk[A + 1],Stk[CB])};
for Idx = 1, C do 
	Stk[CB + Idx] = Result[Idx];
end;
local R = Result[1]
if R then 
	Stk[CB] = R 
	InstrPoint = Inst[3];
else
	InstrPoint = InstrPoint + 1;
end;end; elseif Enum <= 139 then if Enum <= 136 then if Enum > 135 then Stk[Inst[2]]=(Inst[3]~=0);InstrPoint=InstrPoint+1;else local A;Stk[Inst[2]] = Stk[Inst[3]] % Inst[4];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Stk[Inst[3]] + Inst[4];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];
A= Inst[2]
Stk[A] = Stk[A](Unpack(Stk, A + 1, Inst[3])) 
InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Stk[Inst[4]]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];
A= Inst[2]
Stk[A] = Stk[A](Unpack(Stk, A + 1, Inst[3])) 
InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Stk[Inst[4]]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Inst[3];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Inst[3];end; elseif Enum <= 137 then for Idx=Inst[2],Inst[3] do Stk[Idx]=nil;end; elseif Enum > 138 then Stk[Inst[2]] = Stk[Inst[3]] / Inst[4];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]]-Stk[Inst[4]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Stk[Inst[3]] / Inst[4];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Stk[Inst[3]] * Inst[4];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];InstrPoint=Inst[3];else if not Stk[Inst[2]] then InstrPoint=InstrPoint+1;else InstrPoint=Inst[3];end;end; elseif Enum <= 141 then if Enum == 140 then 
local A = Inst[2]; 
do return Unpack(Stk, A, Top) end;else if (Stk[Inst[2]]<Stk[Inst[4]])then InstrPoint=Inst[3]; else InstrPoint=InstrPoint+1; end;end; elseif Enum <= 142 then Stk[Inst[2]] = Stk[Inst[3]] * Inst[4]; elseif Enum == 143 then Stk[Inst[2]] = Stk[Inst[3]] % Inst[4];else Env[Inst[3]] = Stk[Inst[2]];end;
				InstrPoint	= InstrPoint + 1;
			end;
		end;

		A, B = _R(PCall(Loop))
		if not A[1] then
			local line = Chunk[7][InstrPoint] or '?'
			error('ERROR IN ScriptGuard SCRIPT [LINE ' .. line .. ']:' .. A[2])
		else
			return Unpack(A, 2, B)
		end;
	end;
end;	
return Wrap(Deserialize(), {}, GetFEnv())();

